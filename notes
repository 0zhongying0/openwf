"make all" to compile the C++ files. 

== Data set ==

Parameters: DATA_LOC, DATA_TYPE

Each attack takes in elements from the data set in DATA_LOC. 
X-Y elements are considered to be instances of site X and are monitored.
Integer elements Z without a hyphen are considered to be non-monitored elements
in the open world; each should come from a different site.
X, Y should start from 0.

The input files should be well-filtered, i.e. it should not have missing
or empty elements. There should be at least 75 cells in each instance.

Attacks read data based on TRAIN_LIST and TEST_LIST. 
They also need to know if there are any open world elements (OPEN = 0 or 1). 

This archive includes a test data set in batch.zip; unzip it here. 
Since the test data set is very small (due to github's limited size),
note that all attacks will perform quite a bit worse than the presented values in the paper. 

== Generating training/testing set ==

gen-list.py generates those files:

	python gen-list.py options-XX

It takes in options-gen-list, which is based on:
MODE, CLOSED_SITENUM, CLOSED_INSTNUM, OPEN_INSTNUM, DATA_LOC, DATA_TYPE, OUTPUT_LOC, and FOLD. 
It generates two files, OUTPUT_LOC + "trainlist" and OUTPUT_LOC + "testlist". 

Data is in the following format:
Each line is a pair time\tpacketsize.
Packetsize is positive if outgoing and negative if incoming
In the cell format, |packetsize| = 1.

== Non-lev-based attacks ==

To run a non-lev-based attack algorithm, do the following:
	
python attackname.py options

The non-lev-based algorithms are:

Bi-XCor
jac
nb
mnb
timing
Pa-FeaturesSVM
vngpp
kNN
Pa-CUMUL
Ha-kFP

kNN requires flearner.cpp to be compiled. 

== Lev-based attacks == 

Lev-based algorithms are slow, and require pre-processing.
Therefore, running each attack is a two-step process (each step triggered manually).
The first step generally requires computational power. 
Pre-processing starts by compiling clLev:

	mpiCC clLev.cpp -o clLev 

To run:

	mpirun -n CORE_TOTAL ./clLev options
 
The lev files go to OUTPUT_LOC of options-XX. clgen_stratify will read them. 

== dist.cpp ==

Dist.cpp calculates the distance between elements. It takes in the TRAIN_LIST from options as input.
It uses parallel programming like clLev.cpp. 
It does not calculate the distance between testing elements.
It produces a file as follows:

1;2;3;4;73.245 (=distance between site 1 inst 2 and site 3 inst 4 is 73.245)
1;2;3;5;13.1
...

It is able to resume when interrupted, and it is run with 

	mpiCC dist.cpp -o dist
	mpirun -n CORE_TOTAL ./dist options-XX

Normally, the input files must be in cell format:

<time>\t<dir*length>
<time>\t<dir*length>...

It is also able to accept newline-separated features as input. Simply set DIST_FEAT = 1 in options, and the feature files should be in TRAIN_LIST. 

== Output ==

OUTPUT_LOC states where these files are to be created:

1, OUTPUT_LOC + ".log" - contains misc details, but final two lines must be time, TPR: x/x and time, FPR: x/x
2. OUTPUT_LOC + ".results" - contains match classification of every input file
Each line contains (2 + number of classes) tab-delimited numbers.
First is the time, second is the ground truth, and the numbers thereafter are the "match" of each class.
The highest-scoring match is the assigned class. 


